<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <script>
      let player,
        bullets = [],
        enemies = [],
        bossBullets = [],
        fragments = [],
        boss;
      let gameTimer = 0,
        BOSS_SPAWN_TIME = 30,
        gameOver = false;
      let leftJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
      let rightJoy = { active: false, id: -1, x: 0, y: 0, currX: 0, currY: 0 };
      let joySize = 130;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        player = new Player();
      }

      function draw() {
        if (gameOver) {
          background(0, 180);
          fill(255, 50, 50);
          textAlign(CENTER);
          textSize(40);
          text("環境被保麗龍淹沒了！", width / 2, height / 2);
          textSize(20);
          fill(255);
          text("點擊網頁重新挑戰", width / 2, height / 2 + 50);
          return;
        }
        background(10, 15, 25);
        gameTimer += deltaTime / 1000;
        handleInput();

        for (let i = fragments.length - 1; i >= 0; i--) {
          fragments[i].update();
          fragments[i].display();
          if (fragments[i].alpha <= 0) fragments.splice(i, 1);
        }

        player.update();
        player.display();

        if (gameTimer >= BOSS_SPAWN_TIME && !boss) {
          boss = new StyrofoamTitan();
          enemies = [];
        } else if (!boss && frameCount % 60 === 0) {
          enemies.push(new NightMarketMonster());
        }

        if (boss) {
          boss.update();
          boss.display();
          if (boss.hp <= 0) {
            noLoop();
            background(0, 200);
            fill(0, 255, 100);
            textAlign(CENTER);
            textSize(35);
            text("成功淨化保麗龍泰坦！", width / 2, height / 2);
          }
        }
        handleCombat();
        drawUI();
        drawJoystick(leftJoy, color(0, 200, 255, 80));
        drawJoystick(rightJoy, color(255, 50, 50, 80));
      }

      function touchStarted() {
        for (let t of touches) {
          if (t.x < width / 2 && !leftJoy.active) {
            leftJoy.active = true;
            leftJoy.id = t.id;
            leftJoy.x = t.x;
            leftJoy.y = t.y;
            leftJoy.currX = t.x;
            leftJoy.currY = t.y;
          } else if (t.x >= width / 2 && !rightJoy.active) {
            rightJoy.active = true;
            rightJoy.id = t.id;
            rightJoy.x = t.x;
            rightJoy.y = t.y;
            rightJoy.currX = t.x;
            rightJoy.currY = t.y;
          }
        }
        if (gameOver) location.reload();
        return false;
      }
      function touchMoved() {
        for (let t of touches) {
          if (t.id === leftJoy.id) {
            leftJoy.currX = t.x;
            leftJoy.currY = t.y;
          }
          if (t.id === rightJoy.id) {
            rightJoy.currX = t.x;
            rightJoy.currY = t.y;
          }
        }
        return false;
      }
      function touchEnded() {
        let sL = false,
          sR = false;
        for (let t of touches) {
          if (t.id === leftJoy.id) sL = true;
          if (t.id === rightJoy.id) sR = true;
        }
        if (!sL) leftJoy.active = false;
        if (!sR) rightJoy.active = false;
        return false;
      }
      function handleInput() {
        if (leftJoy.active) {
          let a = atan2(leftJoy.currY - leftJoy.y, leftJoy.currX - leftJoy.x);
          let d = dist(leftJoy.x, leftJoy.y, leftJoy.currX, leftJoy.currY);
          let p = constrain(d / (joySize / 2), 0, 1);
          player.vx += cos(a) * 1.6 * p;
          player.vy += sin(a) * 1.6 * p;
        }
        if (rightJoy.active && frameCount % 7 === 0) {
          let a = atan2(
            rightJoy.currY - rightJoy.y,
            rightJoy.currX - rightJoy.x
          );
          if (dist(rightJoy.x, rightJoy.y, rightJoy.currX, rightJoy.currY) > 15)
            bullets.push(new Bullet(player.x, player.y, a));
        }
      }

      class Player {
        constructor() {
          this.x = width / 2;
          this.y = height * 0.8;
          this.vx = 0;
          this.vy = 0;
          this.hp = 100;
        }
        update() {
          this.vx *= 0.88;
          this.vy *= 0.88;
          this.x += this.vx;
          this.y += this.vy;
          this.x = constrain(this.x, 20, width - 20);
          this.y = constrain(this.y, 20, height - 20);
        }
        display() {
          push();
          translate(this.x, this.y);
          fill(0, 150, 255);
          stroke(255);
          rect(-15, -15, 30, 30, 5);
          fill(255);
          noStroke();
          ellipse(0, -5, 12, 8);
          pop();
        }
      }

      class NightMarketMonster {
        constructor() {
          this.x = random(width);
          this.y = -50;
          this.hp = 3;
          this.offset = random(100);
        }
        update() {
          let a = atan2(player.y - this.y, player.x - this.x);
          this.x += cos(a) * 2.2 + sin(frameCount * 0.1 + this.offset) * 1;
          this.y += sin(a) * 2.2;
        }
        display() {
          fill(150, 100, 50);
          stroke(50);
          beginShape();
          for (let i = 0; i < TWO_PI; i += 0.5) {
            let r = 18 + sin(i * 3 + frameCount * 0.2) * 5;
            vertex(this.x + cos(i) * r, this.y + sin(i) * r);
          }
          endShape(CLOSE);
          fill(255);
          ellipse(this.x - 5, this.y - 2, 5, 5);
          ellipse(this.x + 5, this.y - 2, 5, 5);
        }
      }

      class StyrofoamTitan {
        constructor() {
          this.x = width / 2;
          this.y = -100;
          this.targetY = 150;
          this.hp = 200;
          this.maxHp = 200; // 血量改為 200
          this.rot = 0;
        }
        update() {
          if (this.y < this.targetY) this.y += 2;
          this.x = width / 2 + sin(frameCount * 0.02) * 120;
          this.rot += 0.02;

          if (frameCount % 4 === 0)
            fragments.push(
              new Fragment(this.x + random(-60, 60), this.y + random(-40, 40))
            );
          if (frameCount % 45 === 0)
            bossBullets.push(
              new Skewer(
                this.x,
                this.y,
                atan2(player.y - this.y, player.x - this.x)
              )
            );

          // 血量低於 50% (100) 觸發大絕
          if (this.hp < this.maxHp * 0.5) {
            if (frameCount % 10 === 0) {
              for (let i = 0; i < 3; i++) {
                let angle = frameCount * 0.1 + (TWO_PI / 3) * i;
                bossBullets.push(new MicroPlastic(this.x, this.y, angle));
              }
            }
          }
        }
        display() {
          push();
          translate(this.x, this.y);
          rotate(sin(this.rot) * 0.1);
          fill(245);
          stroke(200);
          strokeWeight(2);
          rect(-50, -40, 100, 80, 5);
          rect(-70, -10, 30, 50, 3);
          rect(40, -10, 30, 50, 3);
          fill(255, 50, 50, 200);
          ellipse(0, 0, 40, 35);
          fill(0);
          ellipse(-15, -15, 8, 12);
          ellipse(15, -15, 8, 12);
          pop();
        }
      }

      class MicroPlastic {
        constructor(x, y, a) {
          this.x = x;
          this.y = y;
          this.a = a;
        }
        update() {
          this.x += cos(this.a) * 4;
          this.y += sin(this.a) * 4;
        }
        display() {
          fill(255);
          noStroke();
          rect(this.x, this.y, 6, 6);
        }
      }

      class Skewer {
        constructor(x, y, a) {
          this.x = x;
          this.y = y;
          this.a = a;
        }
        update() {
          this.x += cos(this.a) * 6;
          this.y += sin(this.a) * 6;
        }
        display() {
          fill(255, 255, 0);
          stroke(200, 100, 0);
          push();
          translate(this.x, this.y);
          rotate(this.a);
          rect(0, -2, 25, 5);
          pop();
        }
      }

      class Fragment {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.vy = random(1, 4);
          this.alpha = 255;
          this.r = random(TWO_PI);
        }
        update() {
          this.y += this.vy;
          this.alpha -= 4;
        }
        display() {
          fill(255, this.alpha);
          noStroke();
          push();
          translate(this.x, this.y);
          rotate(this.r);
          rect(0, 0, 8, 8);
          pop();
        }
      }

      class Bullet {
        constructor(x, y, a) {
          this.x = x;
          this.y = y;
          this.a = a;
        }
        update() {
          this.x += cos(this.a) * 15;
          this.y += sin(this.a) * 15;
        }
        display() {
          fill(0, 255, 200);
          noStroke();
          ellipse(this.x, this.y, 12, 12);
        }
      }

      function handleCombat() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i].update();
          bullets[i].display();
          if (boss && dist(bullets[i].x, bullets[i].y, boss.x, boss.y) < 60) {
            boss.hp -= 4;
            bullets.splice(i, 1);
            continue;
          }
          for (let j = enemies.length - 1; j >= 0; j--) {
            if (
              dist(bullets[i].x, bullets[i].y, enemies[j].x, enemies[j].y) < 25
            ) {
              enemies[j].hp--;
              bullets.splice(i, 1);
              if (enemies[j].hp <= 0) enemies.splice(j, 1);
              break;
            }
          }
          if (
            bullets[i] &&
            (bullets[i].x < 0 ||
              bullets[i].x > width ||
              bullets[i].y < 0 ||
              bullets[i].y > height)
          )
            bullets.splice(i, 1);
        }
        for (let e of enemies) {
          e.update();
          e.display();
          if (dist(e.x, e.y, player.x, player.y) < 30) player.hp -= 0.5;
        }
        for (let i = bossBullets.length - 1; i >= 0; i--) {
          bossBullets[i].update();
          bossBullets[i].display();
          if (
            dist(bossBullets[i].x, bossBullets[i].y, player.x, player.y) < 20
          ) {
            player.hp -= 10;
            bossBullets.splice(i, 1);
          } else if (bossBullets[i].y > height || bossBullets[i].y < -100)
            bossBullets.splice(i, 1);
        }
        if (player.hp <= 0) gameOver = true;
      }

      function drawJoystick(joy, col) {
        if (joy.active) {
          fill(col);
          noStroke();
          ellipse(joy.x, joy.y, joySize);
          let a = atan2(joy.currY - joy.y, joy.currX - joy.x);
          let d = min(dist(joy.x, joy.y, joy.currX, joy.currY), joySize / 2);
          fill(255, 150);
          ellipse(joy.x + cos(a) * d, joy.y + sin(a) * d, 60);
        }
      }

      function drawUI() {
        fill(255);
        textSize(18);
        textAlign(LEFT);
        noStroke();
        text(`能源: ${floor(player.hp)}%`, 30, height - 40);
        if (boss) {
          fill(255, 50);
          rect(30, 30, 200, 10);
          fill(255, 50, 50);
          rect(30, 30, (boss.hp / boss.maxHp) * 200, 10);
          text("泰坦血量", 30, 60);
        } else {
          fill(255, 50);
          rect(30, 30, 200, 10);
          fill(0, 255, 150);
          rect(30, 30, (gameTimer / BOSS_SPAWN_TIME) * 200, 10);
          text("環境威脅偵測中...", 30, 60);
        }
      }
    </script>
  </body>
</html>
